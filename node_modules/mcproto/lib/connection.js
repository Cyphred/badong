"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = exports.State = void 0;
const crypto_1 = require("crypto");
const packet_1 = require("./packet");
const transforms_1 = require("./transforms");
const events_1 = require("./events");
var State;
(function (State) {
    State[State["Handshake"] = 0] = "Handshake";
    State[State["Status"] = 1] = "Status";
    State[State["Login"] = 2] = "Login";
    State[State["Play"] = 3] = "Play";
})(State = exports.State || (exports.State = {}));
class Connection extends events_1.Emitter {
    constructor(socket, isServer = false) {
        super();
        this.socket = socket;
        this.isServer = isServer;
        this.state = State.Handshake;
        this.protocol = -1;
        this.paused = false;
        this.packets = [];
        this.reader = new transforms_1.Reader;
        this.writer = new transforms_1.Writer;
        socket.setNoDelay(true);
        socket.on("close", () => {
            this.emit("end");
            this.writer.end();
        });
        socket.on("error", error => this.emitError(error));
        socket.on("close", () => {
            if (!this.writer.writable)
                return;
            this.emit("end");
            this.writer.end();
        });
        this.socket.pipe(this.reader);
        this.writer.pipe(this.socket);
        this.reader.on("error", error => this.socket.destroy(error));
        this.reader.on("data", packet => this.packetReceived(packet));
        this.reader.on("close", () => this.writer.end());
    }
    onPacket(id, handler) {
        return this.on("packet", packet => {
            if (id == null || packet.id == id)
                handler(packet.clone());
        });
    }
    oncePacket(id, handler) {
        const listener = this.onPacket(id, packet => {
            handler(packet);
            listener.dispose();
        });
        return listener;
    }
    pause() {
        this.paused = true;
        this.socket.pause();
        return new Promise(res => this.reader.flush(res));
    }
    async resume() {
        await new Promise(res => this.reader.flush(res));
        for (const packet of this.packets) {
            await Promise.resolve();
            if (!this.socket.writable)
                break;
            this.emit("packet", new packet_1.PacketReader(packet, this.protocol));
        }
        this.packets.length = 0;
        this.paused = false;
        this.socket.resume();
    }
    unpipe() {
        this.socket.unpipe();
        this.writer.unpipe();
    }
    nextPacket(id, expectNext = true) {
        return new Promise((resolve, reject) => {
            const endL = this.on("end", () => (reject(new Error("Server closed")), listener.dispose()));
            const listener = this.on("packet", packet => {
                if (id == null || packet.id == id) {
                    resolve(packet);
                    listener.dispose();
                    endL.dispose();
                }
                else if (expectNext && id != null && packet.id != id) {
                    reject(new Error(`Expected packet with id ${id} but got ${packet.id}`));
                    listener.dispose();
                    endL.dispose();
                }
            });
        });
    }
    send(packet) {
        const buffer = packet instanceof packet_1.PacketWriter
            ? packet.encode()
            : packet instanceof packet_1.PacketReader ? packet.buffer : packet;
        if (!this.isServer && this.state == State.Handshake) {
            const handshake = new packet_1.PacketReader(buffer);
            this.protocol = handshake.readVarInt();
            handshake.readString(), handshake.readUInt16();
            this.setState(handshake.readVarInt());
        }
        if (this.isServer && this.state == State.Login) {
            const packet = new packet_1.PacketReader(buffer);
            if (packet.id == 0x2)
                this.setState(State.Play);
        }
        return new Promise((resolve, reject) => this.writer.write(buffer, error => {
            if (error)
                reject(error);
            else
                resolve();
        }));
    }
    async end(packet) {
        if (packet)
            await this.send(packet);
        this.socket.end();
    }
    setCompression(threshold) {
        if (this.isServer)
            this.send(new packet_1.PacketWriter(0x3).writeVarInt(threshold));
        this.reader.compressionThreshold = threshold;
        this.writer.compressionThreshold = threshold;
    }
    setEncryption(sharedSecret) {
        this.cipher = crypto_1.createCipheriv("aes-128-cfb8", sharedSecret, sharedSecret);
        this.decipher = crypto_1.createDecipheriv("aes-128-cfb8", sharedSecret, sharedSecret);
        this.socket.unpipe(), this.writer.unpipe();
        this.socket.pipe(this.decipher).pipe(this.reader);
        this.writer.pipe(this.cipher).pipe(this.socket);
    }
    setState(state) {
        const oldState = this.state;
        this.state = state;
        if (oldState != state)
            this.emit("changeState", state);
    }
    packetReceived(buffer) {
        if (!this.socket.writable)
            return;
        if (this.paused)
            this.packets.push(buffer);
        else
            this.emit("packet", new packet_1.PacketReader(buffer, this.protocol));
        const packet = new packet_1.PacketReader(buffer);
        if (this.isServer) {
            if (this.state == State.Handshake) {
                this.protocol = packet.readVarInt();
                packet.readString(), packet.readUInt16();
                this.setState(packet.readVarInt());
            }
            return;
        }
        if (this.state == State.Login)
            switch (packet.id) {
                case 0x2:
                    this.setState(State.Play);
                    break;
                case 0x3:
                    this.setCompression(packet.readVarInt());
                    break;
            }
    }
    emitError(error) {
        if (!this.emit("error", error)) {
            console.error("Unhandled connection error", error);
        }
    }
}
exports.Connection = Connection;
