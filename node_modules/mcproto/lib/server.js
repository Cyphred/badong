"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateKeyPair = exports.ServerConnection = exports.Server = void 0;
const net = require("net");
const events_1 = require("./events");
const _1 = require(".");
const packet_1 = require("./packet");
const crypto_1 = require("crypto");
const utils_1 = require("./utils");
const constants_1 = require("constants");
const connection_1 = require("./connection");
const defaultOptions = {
    keepAlive: true,
    keepAliveInterval: 10000,
    generateKeyPair: true
};
class Server extends events_1.Emitter {
    constructor(options, handler) {
        super();
        this.server = new net.Server;
        if (typeof options == "function")
            handler = options, options = undefined;
        this.options = { ...defaultOptions, ...options };
        if (handler)
            this.on("connection", client => {
                const handleError = (error) => {
                    if (!this.emit("error", error)) {
                        console.error("Unhandled connection error:", error);
                    }
                };
                try {
                    const ret = handler(client);
                    if (ret instanceof Promise)
                        ret.catch(handleError);
                }
                catch (error) {
                    handleError(error);
                }
            });
        this.server.on("error", error => {
            if (!this.emit("error", error)) {
                throw error;
            }
        });
        this.server.on("connection", socket => {
            this.emit("connection", new ServerConnection(socket, this));
        });
        if (this.options.generateKeyPair) {
            ({ publicKey: this.publicKey, privateKey: this.privateKey } = generateKeyPair());
        }
    }
    static async encrypt(client, publicKey, privateKey, username, verify = true) {
        const serverId = crypto_1.randomBytes(4).toString("hex");
        const verifyToken = crypto_1.randomBytes(4);
        client.send(new packet_1.PacketWriter(0x1).writeString(serverId)
            .writeVarInt(publicKey.length).write(publicKey)
            .writeVarInt(verifyToken.length).write(verifyToken));
        const res = await client.nextPacket(0x1);
        const encryptedSharedKey = res.read(res.readVarInt());
        const encryptedVerifyToken = res.read(res.readVarInt());
        const clientVerifyToken = crypto_1.privateDecrypt({ key: privateKey, padding: constants_1.RSA_PKCS1_PADDING }, encryptedVerifyToken);
        if (!verifyToken.equals(clientVerifyToken)) {
            client.end();
            throw new Error("Token verification failed");
        }
        const sharedKey = crypto_1.privateDecrypt({ key: privateKey, padding: constants_1.RSA_PKCS1_PADDING }, encryptedSharedKey);
        client.setEncryption(sharedKey);
        if (verify && !await utils_1.hasJoinedSession(username, serverId)) {
            client.end(new packet_1.PacketWriter(0x0).writeJSON({
                translate: "multiplayer.disconnect.unverified_username"
            }));
            throw new Error("Invalid session");
        }
    }
    listen(port, host) {
        return new Promise((resolve, reject) => {
            this.server.once("error", reject);
            this.server.listen(port, host, () => {
                this.server.off("error", reject);
                resolve(this);
            });
        });
    }
    close() {
        return new Promise((resolve, reject) => {
            this.server.close(error => error ? reject(error) : resolve());
        });
    }
}
exports.Server = Server;
class ServerConnection extends _1.Connection {
    constructor(socket, server) {
        super(socket, true);
        this.server = server;
        this.on("changeState", state => {
            if (state == connection_1.State.Play && server.options.keepAlive) {
                this.startKeepAlive();
            }
        });
    }
    startKeepAlive() {
        const ids = packet_1.getPacketIdMap(this.protocol);
        let id = null;
        const keepAliveInterval = setInterval(() => {
            if (id) {
                this.end(new packet_1.PacketWriter(0x0).writeJSON({ text: "Timed out" }));
            }
            id = BigInt(Date.now());
            this.send(new packet_1.PacketWriter(ids.keepAliveC).writeUInt64(id));
        }, this.server.options.keepAliveInterval);
        this.onPacket(ids.keepAliveS, packet => {
            if (packet.readUInt64() == id)
                id = null;
        });
        this.on("end", () => clearInterval(keepAliveInterval));
    }
    encrypt(username, verify = true) {
        const { server } = this;
        if (!server.publicKey || !server.privateKey) {
            throw new Error("Public/private keypair was not generated");
        }
        return Server.encrypt(this, server.publicKey, server.privateKey, username, verify);
    }
}
exports.ServerConnection = ServerConnection;
function generateKeyPair() {
    return crypto_1.generateKeyPairSync("rsa", {
        modulusLength: 1024,
        publicKeyEncoding: { type: "spki", format: "der" },
        privateKeyEncoding: { type: "pkcs8", format: "pem" }
    });
}
exports.generateKeyPair = generateKeyPair;
