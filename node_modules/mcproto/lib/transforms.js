"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reader = exports.Writer = void 0;
const stream_1 = require("stream");
const varint_1 = require("./varint");
const zlib = require("zlib");
class Writer extends stream_1.Transform {
    constructor() {
        super(...arguments);
        this.compressionThreshold = -1;
    }
    _transform(chunk, _enc, callback) {
        if (this.compressionThreshold == -1) {
            this.push(Buffer.concat([varint_1.encodeVarInt(chunk.length), chunk]));
        }
        else {
            if (chunk.length < this.compressionThreshold) {
                this.push(Buffer.concat([
                    varint_1.encodeVarInt(chunk.length + 1),
                    varint_1.encodeVarInt(0), chunk
                ]));
            }
            else {
                return zlib.deflate(chunk, (error, buffer) => {
                    if (error)
                        return callback(error);
                    const len = varint_1.encodeVarInt(chunk.length);
                    const packetLen = varint_1.encodeVarInt(len.length + buffer.length);
                    this.push(Buffer.concat([packetLen, len, buffer]));
                    callback();
                });
            }
        }
        callback();
    }
}
exports.Writer = Writer;
class Reader extends stream_1.Transform {
    constructor() {
        super(...arguments);
        this.compressionThreshold = -1;
        this.buffer = Buffer.alloc(0);
        this.transforming = false;
    }
    async _transform(chunk, _enc, callback) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        this.transforming = true;
        let offset = 0;
        let length;
        while (true) {
            const packetStart = offset;
            try {
                [length, offset] = varint_1.decodeVarInt(this.buffer, offset);
            }
            catch (err) {
                break;
            }
            if (offset + length > this.buffer.length) {
                offset = packetStart;
                break;
            }
            try {
                if (this.compressionThreshold == -1) {
                    this.push(this.buffer.slice(offset, offset + length));
                }
                else {
                    const [len, off] = varint_1.decodeVarInt(this.buffer, offset);
                    const buffer = this.buffer.slice(off, offset + length);
                    if (len == 0) {
                        this.push(buffer);
                    }
                    else {
                        this.push(await new Promise((resolve, reject) => {
                            zlib.inflate(buffer, {
                                finishFlush: zlib.constants.Z_SYNC_FLUSH
                            }, (error, buffer) => {
                                if (error)
                                    reject(error);
                                else
                                    resolve(buffer);
                            });
                        }));
                    }
                }
            }
            catch (error) {
                return this.destroy(error);
            }
            offset += length;
            await Promise.resolve();
        }
        this.buffer = this.buffer.slice(offset);
        this.flushCb && this.flushCb();
        this.transforming = false;
        callback();
    }
    flush(callback) {
        if (this.transforming) {
            this.flushCb = callback;
        }
        else {
            callback();
        }
    }
}
exports.Reader = Reader;
