"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const crypto_1 = require("crypto");
const constants_1 = require("constants");
const net_1 = require("net");
const dns = require("dns");
const _1 = require(".");
const utils_1 = require("./utils");
const defaultOptions = {
    keepAlive: true,
    connectTimeout: 10000,
    timeout: 120000
};
class Client extends _1.Connection {
    constructor(options) {
        super(new net_1.Socket, false);
        this.options = { ...defaultOptions, ...options };
        this.socket.on("timeout", () => this.socket.destroy());
        this.on("changeState", this.stateChanged.bind(this));
    }
    static connect(host, port, options) {
        const client = new Client(options);
        return client.connect(host, port);
    }
    async connect(host, port) {
        const isIp = host.includes(":") || /^([0-9]+\.){3}[0-9]+$/.test(host);
        const isDomain = !isIp && /^(\w+\.)+(\w+)?$/i.test(host);
        if (isDomain && !port)
            port = await new Promise(resolve => {
                dns.resolveSrv("_minecraft._tcp." + host, (err, addrs) => {
                    if (err || addrs.length == 0)
                        return resolve(25565);
                    host = addrs[0].name;
                    resolve(addrs[0].port);
                });
            });
        return new Promise((resolve, reject) => {
            this.once("error", reject);
            this.socket.setTimeout(this.options.connectTimeout || 0, () => {
                this.socket.destroy();
                reject(new Error("Connection timed out"));
            });
            this.socket.connect({ host, port: port || 25565 }, () => {
                this.removeListener("error", reject);
                this.socket.setTimeout(this.options.timeout || 0);
                resolve(this);
            });
        });
    }
    stateChanged(state) {
        if (state == _1.State.Login) {
            const disposeListener = this.onPacket(0x1, this.onEncryptionRequest.bind(this));
            this.once("changeState", disposeListener.dispose);
        }
        else if (state == _1.State.Play && this.options.keepAlive) {
            const ids = _1.getPacketIdMap(this.protocol);
            this.onPacket(ids.keepAliveC, packet => {
                this.send(new _1.PacketWriter(ids.keepAliveS).writeInt64(packet.readInt64()));
            });
        }
    }
    async onEncryptionRequest(req) {
        const serverId = req.readString();
        const publicKey = req.read(req.readVarInt());
        const verifyToken = req.read(req.readVarInt());
        const sharedSecret = crypto_1.randomBytes(16);
        const hashedServerId = utils_1.mcHexDigest(crypto_1.createHash("sha1")
            .update(serverId)
            .update(sharedSecret)
            .update(publicKey)
            .digest());
        if (!await utils_1.joinSession(this.options.accessToken, this.options.profile, hashedServerId)) {
            this.emitError(new Error("Invalid access token"));
        }
        const key = utils_1.mcPublicKeyToPem(publicKey);
        const encryptedSharedKey = crypto_1.publicEncrypt({ key, padding: constants_1.RSA_PKCS1_PADDING }, sharedSecret);
        const encryptedVerifyToken = crypto_1.publicEncrypt({ key, padding: constants_1.RSA_PKCS1_PADDING }, verifyToken);
        this.send(new _1.PacketWriter(0x1)
            .writeVarInt(encryptedSharedKey.length).write(encryptedSharedKey)
            .writeVarInt(encryptedVerifyToken.length).write(encryptedVerifyToken));
        this.setEncryption(sharedSecret);
    }
}
exports.Client = Client;
